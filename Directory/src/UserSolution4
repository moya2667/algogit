
class UserSolution4 {

	private final static int NAME_MAXLEN = 6;
	private final static int PATH_MAXLEN = 1999;

	int mstrcmp(char[] a, char[] b) {
		int i;
		for (i = 0; a[i] != '\0'; i++) {
			if (a[i] != b[i])
				return a[i] - b[i];
		}
		return a[i] - b[i];
	}

	void mstrcpy(char[] dest, char[] src) {
		int i = 0;
		while (src[i] != '\0') {
			dest[i] = src[i];
			i++;
		}
		dest[i] = src[i];
	}

	class dir {

		char[] name = new char[6];
		ll childs = new ll();
		dir pa;

		dir ne, pe;

		dir() {};

		dir(char[] n) {
			mstrcpy(this.name, n);
		}

		class ll {
			dir h, t;

			dir add(dir d) {
				if (h == null) {
					h = d;
					t = d;
					return d;
				}
				t.ne = d;
				d.pe = t;
				t = d;
				return d;
			}

			// 맞나
			void delete(dir d) {
				if (d == h && d == t) {
					h = null;
					t = null;
					return;
				}

				if (d == h) {
					d.ne.pe = null;
					h = d.ne;
				} else if (d == t) {
					d.pe.ne = null;
					t = d.pe;
				} else {
					d.pe.ne = d.ne;
					d.ne.pe = d.pe;
				}

				d.pe = null;
				d.ne = null;
			}

			dir find(char[] p) {
				dir he = h;
				while (he != null) {
					if (mstrcmp(he.name, p) == 0) {
						return he;
					}
					he = he.ne;
				}
				return null;
			}
		}
	}

	dir[] dirs;

	void init(int n) {
		// 미리 생성 한다면, 바로 찾을수 있는 장점은.?
		/*
		 * for (int i= 0; i<n ;i++) { dirs[i] = new dir(); }
		 */

		mytree = new tree();
	}

	class tree {
		dir root;

		tree() {
			char[] r = new char[2];
			r[0] = '/';
			r[1] = '\0';
			root = new dir(r);
		}

		dir mkdir(dir d, char[] name) {
			dir c = new dir(name);
			c.pa = d;
			d.childs.add(c);
			return c;
		}

		boolean isroot(char[] path, char c) {
			if (path[0] == c && path[1] == '\0')
				return true;
			return false;
		}

		dir finddir = null;

		dir find(char[] path) {
			// path = /a/bd/cc/
			if (isroot(path, '/')) {
				return root;
			}

			finddir = null;
			findrecu(root, path, 1);

			return finddir;
		}

		void findrecu(dir r, char[] path, int s) {
			if (r == null)
				return;
			finddir = r;

			// get path = '/' 까지
			char[] p = new char[6];
			int c = 0;
			int i = 0;
			for (i = s; i < path.length; i++) {
				if (path[i] == '/') {
					p[c] = '\0';
					break;
				}
				p[c++] = path[i];
			}

			dir f = r.childs.find(p);
			findrecu(f, path, i+1);
		}

		void rm(dir d) {
			dir parent = d.pa;
			
			
            dir he = parent.childs.h;
            while (he != null) {
                if (mstrcmp(he.name, d.name) == 0) {
                    parent.childs.delete(he);
                    break;
                }
                he = he.ne;
            }
		}

		void print(dir d, int dep) {
			if (d == null)
				return;

			for (int i = 0; i <= dep; i++) {
				System.out.print("+");
			}
			System.out.println(new String(d.name));

			dir he = d.childs.h;
			while (he != null) {
				print(he, dep + 1);
				he = he.ne;
			}
		}

		int cnt = 0;

		public void getcount(dir d) {
			if (d == null)
				return;

			dir he = d.childs.h;
			while (he != null) {
				cnt++;
				getcount(he);
				he = he.ne;
			}
		}

		public void mv(dir s, dir d) {
			dir parent = s.pa;
			parent.childs.delete(s); 
			
			d.childs.add(s);
			d = s.pa ; //consider 
		}

		public void cp(dir sr, dir dt) {
			if (sr == null) return;
			
			dir c = this.mkdir(dt, sr.name);
			
			dir he = sr.childs.h;
			while(he!=null) {
				cp(he,c);
				he = he.ne;
			}
		}

	}

	tree mytree;

	void cmd_mkdir(char[] path, char[] name) {
		System.out.println("cmd_mkdir");
		dir d = mytree.find(path);
		mytree.mkdir(d, name);
		mytree.print(mytree.root, 0);
	}

	void cmd_rm(char[] path) {
		System.out.println("cmd_rm");
		dir d = mytree.find(path);
		mytree.rm(d);
		mytree.print(mytree.root, 0);
	}

	void cmd_cp(char[] srcPath, char[] dstPath) {
		System.out.println("cmd_cp");
		dir sr = mytree.find(srcPath);
		dir dt = mytree.find(dstPath);
		mytree.cp(sr,dt);
		mytree.print(mytree.root, 0);
		//mytree.rm(d);
	}

	void cmd_mv(char[] srcPath, char[] dstPath) {
		System.out.println("cmd_mv");
		dir s = mytree.find(srcPath);
		dir d = mytree.find(dstPath);
		System.out.println("T");
		mytree.mv(s, d);
		mytree.print(mytree.root, 0);
	}

	int cmd_find(char[] path) {
		System.out.println("cmd_find " + new String(path));
		dir d = mytree.find(path);
		mytree.cnt = 0;
		mytree.getcount(d);
		return mytree.cnt;
	}
}
